{"version":3,"sources":["../src/simple-call-x.js"],"names":[],"mappings":"AAAA,OAAO,IAAP,MAAiB,eAAjB;AACA,OAAO,WAAP,MAAwB,gBAAxB;AACA,OAAO,eAAP,MAA4B,sBAA5B;AAEA,IAAM,UAAU,GAAG,SAAnB;IACc,W,GAAiC,I,CAAxC,K;IAA0B,U,GAAc,I,CAApB,I;AAC3B,IAAM,MAAM,GAAG,IAAI,CAAC,UAAD,EAAa,WAAb,CAAnB;AACA,IAAM,WAAW,GAAG,IAAI,CAAC,WAAD,EAAc,GAAG,QAAjB,CAAxB;AACA,IAAM,aAAa,GAAG,oBAAtB;AACA,IAAM,QAAQ,GAAG,mBAAjB;;AAEA,IAAM,gBAAgB,GAAG,SAAS,gBAAT,CAA0B,KAA1B,EAAiC;AACxD,MAAI,OAAO,KAAP,KAAiB,UAAjB,IAA+B,WAAW,CAAC,KAAD,CAAX,KAAuB,QAA1D,EAAoE;AAClE,UAAM,IAAI,UAAJ,CAAe,KAAK,GAAG,aAAvB,CAAN;AACD;;AAED,SAAO,KAAP;AACD,CAND;;AAQA,IAAM,OAAO,GAAG,SAAS,OAAT,CAAiB,SAAjB,EAA4B;AAC1C,MAAM,MAAM,GAAG,EAAf;;AAEA,MAAI,OAAO,SAAP,KAAqB,QAArB,IAAiC,WAAW,CAAC,SAAD,CAAhD,EAA6D;AAC3D,WAAO,MAAP;AACD;;AAED,MAAM,QAAQ,GAAG,eAAe,CAAC,SAAD,CAAhC;AACA,MAAM,GAAG,GAAG,QAAQ,CAAC,MAArB;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,IAAI,CAA9B,EAAiC;AAC/B,IAAA,MAAM,CAAC,MAAM,CAAC,MAAR,CAAN,GAAwB,QAAQ,CAAC,CAAD,CAAhC;AACD;;AAED,SAAO,MAAP;AACD,CAfD,C,CAiBA;AACA;;AACA;;;;;;;;;;;AAWA;;;AACA,IAAM,IAAI,GAAG,SAAS,IAAT,CAAc,CAAd,EAAiB,CAAjB,EAAoB;AAC/B;AACA,SAAO,MAAM,CAAC,gBAAgB,CAAC,CAAD,CAAjB,EAAsB,CAAtB,EAAyB,OAAO,CAAC,SAAS,CAAC,CAAD,CAAV,CAAhC,CAAb;AACD,CAHD;;AAKA,eAAe,IAAf","file":"simple-call-x.esm.js","sourcesContent":["import bind from 'simple-bind-x';\nimport isPrimitive from 'is-primitive-x';\nimport splitIfBoxedBug from 'split-if-boxed-bug-x';\n\nconst $TypeError = TypeError;\nconst {apply: nativeApply, call: nativeCall} = bind;\nconst $apply = bind(nativeCall, nativeApply);\nconst toStringTag = bind(nativeApply, {}.toString);\nconst ERROR_MESSAGE = ' is not a function';\nconst funcType = '[object Function]';\n\nconst assertIsFunction = function assertIsFunction(value) {\n  if (typeof value !== 'function' && toStringTag(value) !== funcType) {\n    throw new $TypeError(value + ERROR_MESSAGE);\n  }\n\n  return value;\n};\n\nconst pushAll = function pushAll(arrayLike) {\n  const target = [];\n\n  if (typeof arrayLike !== 'string' && isPrimitive(arrayLike)) {\n    return target;\n  }\n\n  const iterable = splitIfBoxedBug(arrayLike);\n  const len = iterable.length;\n\n  for (let i = 0; i < len; i += 1) {\n    target[target.length] = iterable[i];\n  }\n\n  return target;\n};\n\n// eslint-disable jsdoc/check-param-names\n// noinspection JSCommentMatchesSignature\n/**\n * The abstract operation Call is used to call the [[Call]] internal method of a function object.\n *\n * @function call\n * @param {Function} F - The target function.\n * @param {*} [V] - The context.\n * @param {Array} [args] - Argument to call the function with.\n * @throws {TypeError} If target is not a function.\n * @returns {*} The the result of invoking the function.\n * @see https://www.ecma-international.org/ecma-262/6.0/#sec-call\n */\n// eslint-enable jsdoc/check-param-names\nconst call = function call(F, V) {\n  /* eslint-disable-next-line prefer-rest-params */\n  return $apply(assertIsFunction(F), V, pushAll(arguments[2]));\n};\n\nexport default call;\n"]}